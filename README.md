# Distributed File Server CS4400
Distributed File Server written in Java for CS4400 Internet Applications, 4th year, Trinity College Dublin, by Cade Ryan

## Project Spec
My implementation includes: 
- The ability to Upload files from any location on your computer
- The ability to Download files which have been previous uploaded
- An authentication server which uses a 3-key kerberos style encryption system to authenticate a user and encrypt all data transactions between the client and file server.
- A directory server which references a database of the location of each uploaded file within the file server system to allow for faster querying.
- Caching on the most recently uploaded files so that clients can access these files faster rather than needing to access the file server for the most recent files.
___________________________________________________________________________

### File Server system  
The file server's core functionality is the ability to upload and download files to and from a network of file servers. This implementaion includes 3 file servers (the locations of
which are folders located at C:/Users/Cade/Server1 Server2 and Server3, these folders are created on startup. You will be requested to selected the file you wish to upload using a selection pane.
These selections may included any file that I have tested, including zipped folders. You may then download any file which has been uploaded by selecting download and typing in the filename,
including the file extension (PLEASE NOTE THIS IS CASE SENSITIVE BY DESIGN). ie. downloaded_file.jpg. You will then be asked to select the folder where you would like to store the downloaded
folder, a 'save as' function if you will.
___________________________________________________________________________
  
### Directory Server
When a file is uploaded, it is uploaded to one of the 3 available file servers. The filename and file server containing it is logged into a database which is read by the directory server when
a download is requested. This process searches for the filename which has been requested and returns the server containing the file so that the files can be sent from the fileserver to the client.

This server also serves another purpose in that when a file is being uploaded, the directory server will find in the database if this file has already been previously uploaded. If the file has
not previously been uploaded, then it will go on to be assigned a file server location, though if it has already been uploaded, the directory server will return the file server location so that
it can be replaced with it's newer version. This ensures that there are not different editions of the same file being stored across multiple servers, and also that when a client attempts to
download a file, they will receive the newest (most recently uploaded) version of the file.
___________________________________________________________________________

### Authentication Process
The authentication system has been implemented as described in the project spec using a 3-key protocol. The client sends their username and a login message which has been encryted using their password.
The authentication server decrypts the message associated with that username and if the decrypted message is the login message it was expecting, it knows that the login information was correct.
If this information is correct, the authentication server will then respond with a token containing a session key and a ticket. The ticket is the session key encrypted using a 3rd key known only to
the authentication server and the file server which is going to be connected to the client. This token, the session key and ticket, is encrypted using the clients own password.

To recapitulate:

Token = CP(sessionKey, Ticket)
Ticket = SK(sessionKey)

where:

- A(B) means B has been encrypted using A.
- CP = clients password.
- SK = secret key known to the auth server and file server.
- sessionKey is the key generated by the auth server for this data transaction.


The Client then decrypts the token using their password and uses the sessionKey to encrpyt all data being sent to/ received from the file server. The ticket will also be sent to the file server by the
client. The file server is able to decrypt the ticket because it was encrypted using a secret key known to it, now both the client and the file server have the session key, which can be used to encrypt
and decrypt all data sent between the two, such as files and filenames.
___________________________________________________________________________

### Caching  
My implementation of caching is reletively simplistic. A cache folder is created on startup on the servers and when a file is uploaded, it is also sent to the cach folder to be stored until it is more
than 5 files old. A simple database keeps track of the 5 most recent files, in precise order of how recently they were uploaded. Once a file falls out of this list of the 5 most recent, it gets deleted
from the cach folder. When a client requests to download a file, if it is in the cache folder then the client is connected to the cache instead of the file server and it gets downloaded from there. If
the file is not present in the cache then the process continues as normal with the client getting directed onto the relevant file server instead.
___________________________________________________________________________

to run this code, first have the servers running:

- Client Proxy Server
- Authentication Server
- Directory Server
- FilerServer1
- FileServer2
- FileServer3

this may be done through the command line or through a java environment like eclipse.

Then once those 6 processes are running, the client can be run. This will allow you to complete a single data transaction such as an upload or download. For more transactions, the client process can
be run multiple times, either concurrently or sequentially. The servers will keep running in the background until their processes are ended.

The Client username and password do not need to be entered, they are currently present in the code within the client process just to simplify the use of the tool.

